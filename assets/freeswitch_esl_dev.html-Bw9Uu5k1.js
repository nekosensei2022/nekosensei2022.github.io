import{_ as i,c as a,a as s,o as l}from"./app-DR6COoGg.js";const r={};function d(n,e){return l(),a("div",null,e[0]||(e[0]=[s('<p>最近用 Go 语言开发了一个基于 FreeSWITCH 的小模块。</p><p>功能很简单，利用 inbound 模式的 ESL 来实现呼叫接续。这里记录一下一些关键的点，以防忘记。</p><h2 id="相关-fs-命令" tabindex="-1"><a class="header-anchor" href="#相关-fs-命令"><span>相关 FS 命令</span></a></h2><p>本次开发，主要是用 ESL 来收取事件，获得呼叫的状态，然后通过命令，向 FS 下达指令，从而达到控制呼叫的目的。</p><p>用到的命令主要有：</p><h3 id="originate" tabindex="-1"><a class="header-anchor" href="#originate"><span>originate</span></a></h3><p>用于发起 B 侧呼叫。</p><p>用法类似这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>originate {origination_caller_id_number=111}sofia/gateway/test/222 &amp;park</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表示：</p><ul><li>通过指定的网关（&quot;test&quot;）</li><li>向被叫（&quot;222&quot;）发起呼叫</li><li>并且显示指定的主叫号码（&quot;111&quot;）</li><li>呼叫接通后进入暂停状态（&quot;&amp;park&quot;）</li></ul><h3 id="uuid-ring-back" tabindex="-1"><a class="header-anchor" href="#uuid-ring-back"><span>uuid_ring_back</span></a></h3><p>用于发送 SIP 180 消息。</p><h3 id="uuid-pre-answer" tabindex="-1"><a class="header-anchor" href="#uuid-pre-answer"><span>uuid_pre_answer</span></a></h3><p>用于发送 SIP 183 消息。</p><h3 id="uuid-answer" tabindex="-1"><a class="header-anchor" href="#uuid-answer"><span>uuid_answer</span></a></h3><p>用于接通 A 侧呼叫（主叫呼入 FS 的呼叫）。</p><h3 id="uuid-bridge" tabindex="-1"><a class="header-anchor" href="#uuid-bridge"><span>uuid_bridge</span></a></h3><p>用于桥接两个呼叫（A 侧和 B 侧）。</p><h3 id="uuid-kill" tabindex="-1"><a class="header-anchor" href="#uuid-kill"><span>uuid_kill</span></a></h3><p>用于挂断呼叫。之后可以跟 cause，用来指定挂断原因（例如 B 侧拒接时，可以通过 cause 来向 A 侧同样发送拒接）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>uuid_kill uuid cause</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="uuid-record" tabindex="-1"><a class="header-anchor" href="#uuid-record"><span>uuid_record</span></a></h3><p>用于录音。</p><p>可以通过设置通道变量来控制录主叫、被叫或立体声。</p><ul><li>录主叫：对 A 侧设置<code>RECORD_READ_ONLY</code>为 true，然后调用录音命令。</li><li>录被叫：对 B 侧设置<code>RECORD_READ_ONLY</code>为 true，然后调用录音命令。</li><li>录立体声：对 A 或 B 侧设置<code>RECORD_STEREO</code>为 true，并确保<code>RECORD_READ_ONLY</code>和<code>RECORD_WRITE_ONLY</code>为 false，然后调用录音命令。</li></ul><h3 id="uuid-setvar" tabindex="-1"><a class="header-anchor" href="#uuid-setvar"><span>uuid_setvar</span></a></h3><p>用于设置通道变量。</p><h2 id="需要注意的点" tabindex="-1"><a class="header-anchor" href="#需要注意的点"><span>需要注意的点</span></a></h2><h3 id="cause-与-status-的映射" tabindex="-1"><a class="header-anchor" href="#cause-与-status-的映射"><span>cause 与 status 的映射</span></a></h3><p>在调用<code>uuid_kill</code>挂断通道时，其实存在 cause (Q.850) 与 SIP status 的多对多映射问题。</p><p>例如：</p><ul><li>B 侧返回 SIP 401（拒接），其对应的 cause 为 21</li><li>21 与 401 不是一一对应关系，它同时对应 401/402/403/603</li><li>调用<code>uuid_kill uuid 21</code>时，FreeSWITCH 会将它翻译为 603</li><li>A 侧收到 SIP 603消息，虽然也是拒接的语义，但从更严格的角度看，FreeSWITCH 其实并没有将 B 侧的消息忠实地传递给 A 侧。</li></ul>',33)]))}const u=i(r,[["render",d],["__file","freeswitch_esl_dev.html.vue"]]),c=JSON.parse('{"path":"/freeswitch_esl_dev.html","title":"FreeSWITCH ESL 开发小结","lang":"zh-CN","frontmatter":{"title":"FreeSWITCH ESL 开发小结","lang":"zh-CN","tag":["FreeSWITCH"],"category":["FreeSWITCH"]},"headers":[{"level":2,"title":"相关 FS 命令","slug":"相关-fs-命令","link":"#相关-fs-命令","children":[{"level":3,"title":"originate","slug":"originate","link":"#originate","children":[]},{"level":3,"title":"uuid_ring_back","slug":"uuid-ring-back","link":"#uuid-ring-back","children":[]},{"level":3,"title":"uuid_pre_answer","slug":"uuid-pre-answer","link":"#uuid-pre-answer","children":[]},{"level":3,"title":"uuid_answer","slug":"uuid-answer","link":"#uuid-answer","children":[]},{"level":3,"title":"uuid_bridge","slug":"uuid-bridge","link":"#uuid-bridge","children":[]},{"level":3,"title":"uuid_kill","slug":"uuid-kill","link":"#uuid-kill","children":[]},{"level":3,"title":"uuid_record","slug":"uuid-record","link":"#uuid-record","children":[]},{"level":3,"title":"uuid_setvar","slug":"uuid-setvar","link":"#uuid-setvar","children":[]}]},{"level":2,"title":"需要注意的点","slug":"需要注意的点","link":"#需要注意的点","children":[{"level":3,"title":"cause 与 status 的映射","slug":"cause-与-status-的映射","link":"#cause-与-status-的映射","children":[]}]}],"git":{"createdTime":1737599978000,"updatedTime":1737599978000,"contributors":[{"name":"nekosensei2022","username":"nekosensei2022","email":"protowc@gmail.com","commits":1,"url":"https://github.com/nekosensei2022"}]},"readingTime":{"minutes":1.72,"words":517},"filePathRelative":"freeswitch_esl_dev.md","localizedDate":"2025年1月23日","excerpt":"<p>最近用 Go 语言开发了一个基于 FreeSWITCH 的小模块。</p>\\n<p>功能很简单，利用 inbound 模式的 ESL 来实现呼叫接续。这里记录一下一些关键的点，以防忘记。</p>\\n<h2>相关 FS 命令</h2>\\n<p>本次开发，主要是用 ESL 来收取事件，获得呼叫的状态，然后通过命令，向 FS 下达指令，从而达到控制呼叫的目的。</p>\\n<p>用到的命令主要有：</p>\\n<h3>originate</h3>\\n<p>用于发起 B 侧呼叫。</p>\\n<p>用法类似这样：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>originate {origination_caller_id_number=111}sofia/gateway/test/222 &amp;park</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{u as comp,c as data};
